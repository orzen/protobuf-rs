use log::debug;
use std::fmt::Display;

use crate::error::ParserError;
use crate::token::Type;
use crate::token_stream::TokenStream;
use crate::types::enumerate::Enum;
use crate::types::import::Import;
use crate::types::message::Message;
use crate::types::option_field::OptionField;
use crate::types::package::Package;
use crate::types::service::Service;
use crate::types::syntax::Syntax;

use super::comment::{BlockComment, LineComment};

// TODO From for ProtoMember should probably be generated by macro
#[derive(Clone, Debug, PartialEq)]
pub enum ProtoMember {
    Enum(Enum),
    Import(Import),
    Message(Message),
    Option(OptionField),
    Package(Package),
    Service(Service),
    LineComment(LineComment),
    BlockComment(BlockComment),
}

impl From<Enum> for ProtoMember {
    fn from(value: Enum) -> Self {
        Self::Enum(value)
    }
}

impl From<Import> for ProtoMember {
    fn from(value: Import) -> Self {
        Self::Import(value)
    }
}

impl From<Message> for ProtoMember {
    fn from(value: Message) -> Self {
        Self::Message(value)
    }
}

impl From<OptionField> for ProtoMember {
    fn from(value: OptionField) -> Self {
        Self::Option(value)
    }
}

impl From<Package> for ProtoMember {
    fn from(value: Package) -> Self {
        Self::Package(value)
    }
}

impl From<Service> for ProtoMember {
    fn from(value: Service) -> Self {
        Self::Service(value)
    }
}

impl From<BlockComment> for ProtoMember {
    fn from(value: BlockComment) -> Self {
        Self::BlockComment(value)
    }
}

impl From<LineComment> for ProtoMember {
    fn from(value: LineComment) -> Self {
        Self::LineComment(value)
    }
}

impl Display for ProtoMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Enum(v) => write!(f, "{}", v),
            Self::Import(v) => write!(f, "{}", v),
            Self::Message(v) => write!(f, "{}", v),
            Self::Option(v) => write!(f, "{}", v),
            Self::Package(v) => write!(f, "{}", v),
            Self::Service(v) => write!(f, "{}", v),
            Self::LineComment(v) => write!(f, "{}", v),
            Self::BlockComment(v) => write!(f, "{}", v),
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Proto {
    syntax: Syntax,
    package: Package,
    members: Vec<ProtoMember>,
}

impl Proto {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn push(&mut self, member: ProtoMember) {
        self.members.push(member);
    }

    pub fn set_package(&mut self, p: Package) {
        self.package = p;
    }

    pub fn set_syntax(&mut self, s: Syntax) {
        self.syntax = s;
    }
}

impl TryFrom<TokenStream> for Proto {
    type Error = ParserError;

    fn try_from(mut tokens: TokenStream) -> Result<Self, Self::Error> {
        debug!("proto({:?})", tokens);

        let mut proto = Self::new();

        while !tokens.is_empty() {
            let peek_token = match tokens.peek() {
                Some(v) => v,
                None => {
                    return Err(ParserError::Syntax(
                        "protobuf member".to_string(),
                        "nothing".to_string(),
                    ))
                }
            };

            // Tokens are order according to expected frequency
            match peek_token.typ() {
                Type::Message => {
                    let block = tokens.select_block(Type::LBrace, Type::RBrace);
                    let message = ProtoMember::from(Message::try_from(block)?);
                    proto.push(ProtoMember::from(message));
                }
                Type::Service => {
                    let block = tokens.select_block(Type::LBrace, Type::RBrace);
                    let service = Service::try_from(block)?;
                    proto.push(ProtoMember::from(service));
                }
                Type::Enum => {
                    let block = tokens.select_block(Type::LBrace, Type::RBrace);
                    let enm = Enum::try_from(block)?;
                    proto.push(ProtoMember::from(enm));
                }
                Type::Option => {
                    let line = tokens.select_until(Type::Semicolon);
                    let option = OptionField::try_from(line)?;
                    proto.push(ProtoMember::from(option));
                }
                Type::Import => {
                    let line = tokens.select_until(Type::Semicolon);
                    let import = Import::try_from(line)?;
                    proto.push(ProtoMember::from(import));
                }
                Type::Syntax => {
                    let line = tokens.select_until(Type::Semicolon);
                    let syntax = Syntax::try_from(line)?;
                    proto.set_syntax(syntax);
                }
                Type::Package => {
                    let line = tokens.select_until(Type::Semicolon);
                    let package = Package::try_from(line)?;
                    proto.set_package(package);
                }
                Type::Slash => {
                    if tokens.is_line_comment() {
                        let line = tokens.select_line_comment()?;
                        let comment = LineComment::from(line);
                        proto.push(ProtoMember::from(comment));
                    }
                    if tokens.is_block_comment() {
                        let block = tokens.select_block_comment()?;
                        let comment = BlockComment::from(block);
                        proto.push(ProtoMember::from(comment));
                    }
                }
                invalid => {
                    return Err(ParserError::Syntax(
                        "protobuf member".to_string(),
                        format!("{invalid}"),
                    ))
                }
            }
        }

        return Ok(proto);
    }
}
